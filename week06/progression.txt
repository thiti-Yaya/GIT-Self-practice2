// First-Class and Higher-Order Functions
const greet = (name, formatter) => formatter(name) //Higher-Order Function -> รับชื่อและฟังก์ชัน formatter มาประมวลผล
const shout = text => text.toUpperCase() + '!!!' //First-Class -> ทำให้ตัวอักษรเป็นพิมพ์ใหญ่ และเพิ่ม !!! 
const whisper = text => text.toLowerCase() + '...' //First-Class -> ทำให้ตัวอักษรเป็นพิมพ์เล็ก และเพิ่ม ...
const emoji = text => text + '❤️' //First-Class -> เพิ่มหัวใจ ❤️ ต่อท้ายข้อความ 
console.log(greet('Alice', shout)); // ALICE!!!
console.log(greet('Beam', whisper)); // beam...
console.log(greet('Amolnut', emoji)); // Amolnut❤️
-- โดยสร้างฟังก์ชัน greet() ที่รับฟังก์ชันอื่น (formatter) 
มาช่วยปรับแต่งข้อความได้หลากหลายรูปแบบ เช่น แปลงเป็นตัวใหญ่ ตัวเล็ก หรือเติมอีโมจิ

-- Higher-Order Functions 
function ที่รับ function อื่น เป็น parameterได้ หรือ return functionไปเป็นผลรับได้  

// Declarative Code
const numbers = [1, 2, 3, 4, 5]
const doubleEvenNumbers = numbers.filter(num => num % 2 === 0) .map(num => num * 2) // function เรียกต่อกัน = compose
console.log(doubleEvenNumbers); // [4, 8]

//Immutability  ไม่ควรแก้ไขค่า -> return เป็น new array
ex. filter, map

const number = [1, 2, 3, 4, 5]
const addOne = (x) => x + 1
const isEven = (x) => x % 2 === 0
const sum = (total, x) => total + x
const incrementedNumbers = number.map(addOne)
const evenNumbers = incrementedNumbers.filter(isEven)
const total = evenNumbers.reduce(sum, 0)
console.log('Original numbers:', number) // Original numbers: [1, 2, 3, 4, 5]
console.log('Incremented numbers:', incrementedNumbers) // Incremented numbers: [2, 3, 4, 5, 6]
console.log('Even numbers:', evenNumbers) // Even numbers: [2, 4, 6]
console.log('Total of even numbers:', total) // Total of even numbers: 12
//compose function
//const result = numbers.map(addOne).filter(isEven).reduce(sum, 0)



// Pure Functions
//pure
const pureFunc = (a, b) => a * b;
console.log(pureFunc(2, 3)); // 6

//pure
const data = {value : 10}
function pureFunc(arg){
let z = 2
arg = arg * z + 1
return arg
}
console.log(pureFunc(datas.value)) // 21

//impure 
let x = 10 
let y = 20 
function impureFunc(arg){
arg = arg + x * 2
return arg
}
console.log(impureFunc(y)) //40
-- impure เพราะ มีตัวแปร x, y ที่เป็น global เป็นตัวแปรที่ไม่ได้เป็นตัวแปรภายใน function


//impure
const data1 = {value : 10}
function impureFunc2(arg){
let z = 2
arg.value = arg.value * z + 1
return arg.value
}
console.log(impureFunc2(data1)) // 21
console.log(impureFunc2(data1)) // 43



-- function ที่ดี

1.บอกให้ได้ว่า function นั้นทำอะไร 
ex. filter เป็นfunction ที่ทำหน้าที่คัดกรอง array ตามเงื่อนไข
filter เป็น Higher-Order Functions เพราะเรารับ call back function ที่เป็นการกรองเงื่อนไขเข้ามาทำงาน
3. function ที่ดีไม่ควรเปลี่ยนแปลง Original data (filter)เมื่อfilter ได้ array ใหม่ มันไม่ไปกระทบกับ Original array เดิม คง data เดิม

--Function composition -> การนำฟังก์ชันหลายตัวมาต่อกัน โดยให้ผลลัพธ์ของฟังก์ชันหนึ่ง เป็น input ของฟังก์ชันถัดไป

function getMaxLengthString(arrStrs) {
  return arrStrs.filter(
    (str) => str.length === Math.max(...arrStrs.map((str) => str.length))
  )
}
console.log(getMaxLengthString(['hi', 'hello', 'hello world', 'HELLO WORLD']))
// ['hello world', 'HELLO WORLD']

=> arrStrs.map((str) => str.length)
ใช้ map() เพื่อสร้าง array ใหม่ที่เก็บความยาวของแต่ละ string
=> Math.max(...arrStrs.map(...))
ใช้ Math.max() เพื่อหาค่ามากที่สุดจาก array ที่ได้จากข้อก่อน
เครื่องหมาย ... (spread operator) ใช้ในการกระจายค่าใน array ออกมาเป็น argument ทีละตัว
=>filter() จะเลือกเฉพาะ string ที่ความยาวเท่ากับ 11
** ฟังก์ชันนี้หาความยาวของ string ที่ “ยาวที่สุด” ใน array แล้วคืนค่า string ทั้งหมดที่มีความยาวเท่ากับค่านั้น **



-- function typs --

// Anonymous function -> function ไม่มีชื่อ, ใช้งานครั้งเดียว อ้างถึงไม่ได้
//Anonymous function created as a function expression
function () {}
//Anonymous function created as an arrow function
() => {}

// Named function -> function มีชื่อ, ระบุชื่อไว้ตอนประกาศ ช่วยเรียกซ้ำได้ง่าย
//Function declaration
function foo() {}
//Named function expression
Const barFn=function bar() {}
//Arrow function
const barAF = () => {} 


function a(){
    return "a"
}
function b(){
    return
}

function x(){ // function ซ้อน ดูจากปีกกา
  function y() {} // ฟังก์ชันภายใน x()
  const z = () => {  // อยู่ใน x() เป็น arrow function 
    const m = () => { // อยู่ ภายใน z() 
      function n() {} // อยู่ ในสุด — ภายใน m()
    }
  }
}




//inner (nested) function

function addSquares(a, b) { //ภายใน addSquares มีการประกาศฟังก์ชันอีกตัวชื่อ square(x) → เป็น inner function หรือ nested function
   function square(x) { // function ภายใน
      return x * x // รับค่า x แล้วคืนค่า x²
   }
      return square(a) + square(b) // return resultของ square
}
//square มองเห็นได้เฉพาะใน addSquares


// Arrow function
const addSquares2 = (a, b) => {
        const square = (x) => x * x  // function ภายใน
        return square(a) + square(b)
}
//square มองเห็นได้เฉพาะใน addSquares2



-- Function scope and Nested Functions --
//Function scope and Nested Functions
let y = 100 // -> ถ้ามีตัวแปรเพิ่ม (y = global variable) y อยู่ไม่ได้อยู่ภายใต้ใดๆ ถามว่าfunction สามารถอ้างถึง y ได้ไหม = ได้
const sum = 5
function getScore(x) { // getScore = global function
  let mid = 40
  let final = 30 
  return mid + final + x + y + sum // 175
}
const score = getScore(1)
console.log(score) //71 => return  mid + final + x + y
console.log(x, mid, final) //error เพราะ-> **cannot be accessed** from anywhere outside the function 

-----------------
let y = 100 
let sum = 5
//ถ้า sum = 2  ->  //83 sum เรียกจากค่าล่าสุด
function getScore(x) {
  let y = 10 //local variable ->ใกล้อันไหน อันนั้นก่อน 
  //global variable
  let mid = 40
  let final = 30 
  return mid + final + x + y + sum
}
const score = getScore(1)
console.log(score) //86
console.log(x, mid, final) //-> cannot be accessed from anywhere outside the function 

---------------------
let y = 100 //global variable
let sum = 5
sum = 2
function getScore(x) { //global function
    let y = 10 //local variable
    //global function
    let mid = 40
    let final = 30
    function doSomething() {
        console.log(`doSomrthing: ${y + sum + mid + final}`);
        //83 ->  sum เรียกจากค่าล่าสุด
        //y (global), sum(global), y(local), x(local (parameter)) mid(local), final (local) // อยากให้ y ตัวไหนทำงาน เอาอีกตัวออก
    }
    doSomething () // เรียก Nested Functions ให้ทำงานได้
    return mid + final + x + y + sum
    //return doSomething()
}

const score = getScore (1)
console.log(score);
console.log(doSomething()) // cannot access
//console.log(x, mid, final); //cannot access



-- Closures --
const z = 1
function makeAdder(x) {
    console.log(x); //10
  //  console.log(y); //y is not defined
    console.log(z); //1
    return function doSomething(y) { // yสามารถอ้างถึงข้างนอกได้หมดเลย
        return x + y + z
    }
    // return doSomething // return function
    // return doSomething() //return result of function
}    
const result = makeAdder(10)
console.log(typeof result) 
console.log(result (3)) // 14
console.log(add5(3)) // 3+5+1
console.log(add10(3))// 3+10+1


const getScoringPass = function (scores) { // outter function รับตัวscore
  //bind and store "scores" argument to use in the nested "cuttingPoint" function
  function cuttingPoint(cuttingScore) {  //nested = cuttingScore
    return scores.filter((score) => score >= cuttingScore) // outter return nested score
  }
  return cuttingPoint
}
//fn_cuttingPoint1 and fn_cuttingPoint2 are instance closure functions
//that bind to each their outer parameter "scores"
let fn_cuttingPoint1 = getScoringPass([50, 15, 32, 80, 100])
console.log(fn_cuttingPoint1(50)) //[ 50, 80, 100 ]
let fn_cuttingPoint2 = getScoringPass([-10,-15,-53,-97,-32])
console.log(fn_cuttingPoint2(-30)) //[ -10,-15 ]

-------------------
function counter() { //counter = outter function
  let count = 0
  function increment() { 
    return ++count
  }
  function decrement() {
    return --count
  }
  function getCount() { 
    return count
  }
  //return {
  //  increment,
  //  decrement,
  //  getCount
  //}
  return {
    addCount: increment,
    decrementCount: decrement,
    getCountValue: getCount,
  }
}
//const a = counter()
//console.log(a.addCount()) 
//console.log(a.addCount()) 
//console.log(a.addCount()) 
//console.log(a.decreseCount())
//console.log(a.getCountValue())

const { addCount, declaration, getCountValue } = counter()
console.log(addCount())
console.log(decreseCount())
console.log(getCountValue())
** increment, decrement, getCount => เป็น closure ทั้ง 3ตัว nested function, outter ต้องreturn



----------------------------------------------------------------
practice 
function idGenerator(){
  let idcount = 0
  function generator(){
    return ++idcount
  }
  return generator
}
 
const idGen = idGenerator()
console.log(idGen()) // 1
console.log(idGen()) // 2
console.log(idGen()) // 3


const outerFunction = (x) => {
  return (y) => x + y   
}
const addFive = outerFunction(5)
console.log(addFive(3))

const addTen = outerFunction(10)
console.log(addTen(2))




----------------------------------------------------------------

// Lesson 1: Arrays, Objects, and Functions
 
// 1. Create an empty array to hold the quotes
const quotes = [] // สร้าง array เปล่าไว้เก็บ
 
/*
  2. Function: addQuote
  - Accepts a quote object with id, content, and author
  - Adds it to the quotes array
*/
function addQuote(quote) { // ตรวจสอบข้อมูลก่อนเพิ่ม ว่าต้องเป็น object และมี id, content, author
  if (!quote) {
    console.log("It was null or Undefind");
    return;
  }
 
  if (typeof quote !== "object" || !Number.isInteger(quote.id) || !quote.content || !quote.author) { // ตรวจสอบว่าข้อมูลถูกต้องไหม
    console.log("Some Thing went wrong")
    return;
  }
 
  quotes.push(quote) // เพิ่มข้อมูลเข้า array
  console.log("Add Quote Success");
  return;
  // TODO: Add the quote object to the quotes array
 
}
 
/*
  3. Function: deleteQuote
  - Accepts an id
  - Removes the quote with that id from the array
*/
function deleteQuote(id) {
  if (!id) { //ลบค่าที่มี id ตรงกับที่ส่งมา
    console.log("Id is Null");
    return;
  }
  const index = quotes.findIndex(quote => quote.id === id) // หาตำแหน่งของ quote ที่มี id ตรงกัน
 
  if (index !== -1) { // ถ้าเจอให้ลบออกจาก array
    quotes.splice(index, 1)
    console.log(`Remove ${id} Success`);
    return;
  } else { // ถ้าไม่เจอให้บอกว่า Quote was not found id
    console.log(`Quote was not found id = ${id}`)
    return;
  }
  // TODO: Remove the quote object from the array using the given id
}
 
/*
  4. Function: updateQuote
  - Accepts an id and an object with new content and/or author
  - Updates the quote with the given id
*/
function updateQuote(id, updatedQuote) {
  // TODO: Find the quote by id and update its properties
  if (!id) {
    console.log("Id is Null");
    return;  
  }
  if (!updatedQuote) {
    console.log("It was null or Undefind");
    return;
  }
 
  if (typeof (updatedQuote) !== "object") {
    console.log("It was not Object");
  }
 
  const index = quotes.findIndex(quote => quote.id === id) // หาตำแหน่งของ quote ที่ต้องการอัปเดต
 
  quotes[index] = { ...quotes[index], ...updatedQuote };
  console.log(`Update Id ${id} -> Updatedata = `, updatedQuote); // ใช้ spread operator รวมข้อมูลเก่ากับข้อมูลใหม่
 
  return;
}
 
/*
  5. Function: getAllQuotes
  - Returns all quotes in the array
*/
function getAllQuotes() {
  return quotes;
  // TODO: Return the quotes array
}
 
// 6. Test your functions below
// TODO: Add 3 quotes using addQuote()
 
// TODO: Delete 1 quote using deleteQuote()
 
// TODO: Update 1 quote using updateQuote()
 
// TODO: Print all quotes using getAllQuotes()
// 6. Test your functions below
 
// Add 3 quotes
 
addQuote({ id: 1, content: "tse", author: 'Steve Jobs' })
 
addQuote({ id: 2, content: "Test", author: 'Yoda' })
 
addQuote({
 
  id: 3,
 
  content: 'Simplicity is the ultimate sophistication.',
 
  author: 'Leonardo da Vinci'
 
})
 
// Delete 1 quote
 
deleteQuote(10)
 
// Update 1 quote
 
updateQuote(1, { content: 'Stay hungry. Stay foolish.', author: 'Jobs' })
 
// Print all quotes
 
console.log(getAllQuotes())
